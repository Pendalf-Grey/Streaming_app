# ХОД РАЗРАБОТКИ
______________________________________________________

- Установил зависимости


- Всем __init__ дал __all__ для контроля за import *


- Написал аутентификацию с помощью JWT-токенов и библиотеки AuthX. (посмотреть внимательно)


- Перенёс config-и для аутентификации с помощью JWT в services.


- В пакете database создал async_client и async_db для подключения к Mongo.


- Законнектил MongoDBCompass через .env. 


- Написал функцию create_access_token --- для генерации Токена


- Написал функцию verify_user --- для проверки наличия Токена и ID у юзера в БД, проверки, не истёк ли Токен


- Написал функцию registration --- для добавления пользователя в БД


- Написал функцию login --- для авторизации. Проверка creds + добавление Токена + оборачивание Токена в Куки


- Написал функцию protected_route --- для перехода по защищённому эндпоинту с предварительной проверкой Куки


- create_access_token переместил в services


- На основе функии verify_user создал декоратор @verify_user. Переместил в services


## У меня есть:

1. --- регистрация (добавление юзера в БД)


2. --- авторизация (проверка юзера на нахождение в БД + Токен в Куки) [Токен одинаковый для всех юзеров. Не генерится новый]


3. --- аутентификация (проверка прав юзера) 


4. --- логаут (удаление Куки + выход из системы) [Как будто выходит из системы, но Куки не удаляет]


5. --- редиректы при успешных запросах. 303 при GET в принимающем url, 307 при POST в принимающем url

Буду использовать confluent-kafka для работы с Apache Kafka


## ВАЖНО ПОЧИТАТЬ / ПОДУМАТЬ

- Продумать логику авторизации и аутентификации. (схема в draw.io)


- Подумать о том, как будет проходить авторизация, какие поля запрашивать у БД? Уникальное поле Почта? 
Может тогда почта будет PK, т.е. - уникальная.


- Когда сравниваю пароль юзера при авторизации и пароль, который вытащил из БД - надо хэшировать второй.
И вообще хранить пароль в БД захэшированные. Как это сделать? bcrypt не подкидывается.


- JWT токен кодируется, а не хэшируется. Его можно раскодировать. Какие нечувствительные данные можно в нём хранить?
Мне кажется, что id юзера - это чувствительные данные, их можно подделать.
А если спрятать ключ шифрования - можно подделать токен? Сомнительно. 
Можно работать не с JWT, а с Сессиями,
т.к. у меня высоконагруженное приложение, происходит много запросов, а JWT хранят в себе оч много инфы - они большие.
Сессии в несколько раз короче. Надо подумать и, если всё окей - перейти на сессии. 
Сессии хранятся на сервере, а JWT на стороне клиента. C JWT проще


- Подумать о том, как хэшировать пароль при добавлении в БД и как проверять при авторизации. Расхэшировать нельзя.


- Решить вопрос с подкидыванием нового куки во время авторизации при удалении старого юзером или через /logout


- Apache Kafka будет юзаться как основная шина для передачи данных между микросервисами. Возможно, как сборщик логов
с серверов для последующей передачи в (куда?)(системы аналитики), возможно, для синхронизации данных между различными
системами или БД, возможно, для обработки транзакций.


- Почитать для себя о корутинах и декораторах в пайтон. Как они связаны?


## НА СЛЕД ДЕНЬ

- Почитать о Apache Kafka


- Начать писать Streaming, связывать микросервисы через Kafka


- Задача во время чтения о Kafka:  
    - В общих словах понять как работает Kafka на верхнем уровне  
    - Понять, как работает с БД  
    - Поверхностно изучить методы   
    - Найти интеграцию с Python  
    - Найти интеграцию с MongoDB  
    - Изучить внутреннюю структуру Kafka


- Посмотреть как загонять микросервис в Docker с помощью docker-compose.yml и разрабатывать сразу несколько


# СОСТАВНЫЕ ЧАСТИ И ОСНОВНЫЕ ТЕХНОЛОГИИ
______________________________________________________

- Микросервисы / DDD


- Frontend (React)  
   [регистрация и вход в систему / просмотр потоков других юзеров / создание своего потока / участие в общем чате к трансляции]


- Backend (FastAPI)  
   [аутентификация, авторизация / менеджер потоков / онлайн-чат / API для получения инфы о юзере]


- Streaming Server (Nginx-RTMP)


- DataBase (MongoDB)


- Kafka - основная шина для передачи данных между микросервисами.

______________________________________________________

# БЕКЕНД

______________________________________________________

## _БАЗА ДАННЫХ_

- ### MongoDB


## _STREAMING SERVER_

- ### Nginx-RTMP

Вот пример базовой конфигурации для `Nginx` с модулем `RTMP`, 
который может помочь вам начать

    rtmp {
       server {
           listen 1935;
           chunk_size 4096;
   
           application live {
               live on;
               record off;
           }
       }
    }
   
    http {
       server {
           listen 80;
   
           location / {
               # Web interface, provide your own frontend here
               root html;
               index index.html index.htm;
           }
   
           # HLS configuration if required
           location /hls {
               types {
                   application/vnd.apple.mpegurl m3u8;
                   video/mp2t ts;
               }
               root /tmp;
               add_header Cache-Control no-cache;
           }
       }
    }



## _АУТЕНТИФИКАЦИЯ И АВТОРИЗАЦИЯ_

Буду использовать строгую и нестрогую аутентификацию.

- ### НЕСТРОГАЯ  
   Аутентификация с помощью Google, VK и пр.

- ### СТРОГАЯ  
   Регистрация, аутентификация + авторизация в Streaming_app

- ### ТЕХНОЛОГИИ  
   `OAuth2` (нестрогая) + `JWT` (строгая)

   Использую библиотеку `AuthX`, т.к. есть пример на видео.  
   AuthX поддерживает `JWT`, `OAuth2`, `MongoDB`.  


   Всё то же самое поддерживает и встроенная в FastAPI библиотека Users - она может помочь при реализации более сложной логики авторизации (При желании потом перейду на неё)


## _ДОСТАВКА ВИДЕО_

### CDN

      Если вы используете CDN для доставки видео, 
      DNS будет использоваться для направления пользователей к ближайшему узлу CDN, 
      который может предоставлять контент. 
      Это очень важно для минимизации задержек и улучшения качества стрима.
      
      Существует несколько альтернатив CDN (Content Delivery Network), которые могут использоваться для доставки контента, включая видео, с минимальными задержками и высокой производительностью. Вот некоторые из них:
      
      
      Облачные хранилища:
      
      Amazon S3: Позволяет хранить и доставлять контент, а также интегрируется с Amazon CloudFront для CDN.
      
      Google Cloud Storage: Предоставляет возможность хранения и доставки контента с интеграцией с Google Cloud CDN.
      
      Платформы для стриминга:
      
      Akamai: Один из крупнейших провайдеров CDN, предлагающий решения для стриминга видео.
      
      Cloudflare Stream: Упрощает процесс доставки видео и обеспечивает защиту от DDoS-атак.


## _БАЛАНСИРОВКА НАГРУЗКИ НА СЕРВЕРА И ДОСТУП К СЕРВЕРАМ_

### DNS
      
      Хотя Nginx-RTMP по умолчанию не использует шифрование, он может быть настроен для 
      работы с HLS (HTTP Live Streaming) и DASH (Dynamic Adaptive Streaming over HTTP), 
      которые поддерживают безопасную передачу данных через HTTPS. 
      Убедитесь, что ваш сервер настроен на использование SSL/TLS, что также требует корректной настройки DNS для повышения безопасности.
      
      Существуют различные технологии и сервисы, которые могут дополнить или служить альтернативами DNS (Domain Name System). Вот некоторые из них:
      
      1. Peer-to-Peer (P2P) Системы
      
      IPFS (InterPlanetary File System): Это распределенная система, предназначенная для хранения и распространения данных. IPFS использует уникальные криптографические хэш-адреса, позволяя пользователям находить контент напрямую, минуя традиционные DNS-записи.
      
      Dat Protocol: Протокол, который также позволяет обмениваться данными P2P с использованием уникальных ссылок.
      2. Blockchain Технологии
      
      Ethereum Name Service (ENS): Система доменных имен, которая работает на базе Ethereum и позволяет регистрировать имена, которые могут ссылаться на адреса в блокчейне.
      
      Namecoin: Первая реализация децентрализованной системы доменных имен на основе технологии блокчейн.
      3. Системы маршрутного поиска
      
      MDN (Multicast DNS): Используется в локальных сетях для автоматического обнаружения устройств и сервисов без необходимости использования центрального DNS-сервера.
      
      LLMNR (Link-Local Multicast Name Resolution): Протокол, аналогичный mDNS, используемый для разрешения имен в локальных сетях.
      4. Системы регистрации и управления трафиком
      
      Anycast Routing: Технология, позволяющая использовать один и тот же IP-адрес на нескольких серверах, осуществляя маршрутизацию трафика к ближайшему узлу.
      5. Другие решения
      
      Local Hosts Files: Временные решения для тестирования или разработки, где можно вручную добавлять записи, не используя DNS.
      
      Технологии VPN: Некоторые VPN-сервисы могут предоставлять свои собственные системы разрешения имен, которые могут работать вместо традиционного DNS.
      6. Системы DNS-сервера следующего поколения
      
      DNS over HTTPS (DoH) и DNS over TLS (DoT): Эти технологии обеспечивают более безопасное разрешение доменных имен, защищая запросы от перехвата и манипуляций.
      Каждое из перечисленных решений и технологий имеет свои преимущества и недостатки в зависимости от применяемости, области использования и требований к безопасности и производительности.


______________________________________________________
# ФРОНТЕНД
______________________________________________________

Для стримингового сервиса, где важны интерактивность и производительность, рекомендую рассмотреть следующие варианты:

- `Streamlit`:

Быстрый прототип

- `Flet`:

Если вам нужен кроссплатформенный интерфейс (веб, мобильные, десктоп) с поддержкой интерактивных элементов.
Подходит для создания сложных интерфейсов с использованием Python.

- `Anvil`:

Если вы хотите быстро создать фронтенд с минимальными усилиями и без необходимости писать HTML/CSS/JavaScript.

- `Dash`:

Если ваш сервис связан с аналитикой или визуализацией данных (например, статистика просмотров, графики)
(статистика в ЛК юзера).

- `Pynecone`:

Если вам нужен современный и производительный фронтенд с поддержкой React.

Пример использования Flet
Если вы выберете Flet, вот пример простого интерфейса для стримингового сервиса:


    import flet as ft
    
    def main(page: ft.Page):
        page.title = "Стриминговый сервис"
        page.vertical_alignment = ft.MainAxisAlignment.CENTER
    
        video_url = ft.TextField(label="Ссылка на видео", width=300)
        play_button = ft.ElevatedButton("Воспроизвести")
    
        def play_video(e):
            page.add(ft.Video(video_url.value))
            page.update()
    
        play_button.on_click = play_video
    
        page.add(
            ft.Column(
                [
                    video_url,
                    play_button,
                ],
                alignment=ft.MainAxisAlignment.CENTER,
            )
        )

    ft.app(target=main)

Этот пример создает простой интерфейс для ввода ссылки на видео и его воспроизведения. 
Вы можете расширить его, добавив логику для управления стримами, плейлистами и другими функциями.


______________________________________________________
# ВВЕДЕНИЕ В ПРОЕКТ
# НАЧАЛО РАБОТЫ С POETRY
______________________________________________________

## _Установка poetry_
   Если poetry ещё не установлен, установите его с помощью следующей команды:
  
  `curl -sSL https://install.python-poetry.org | python3 -`  

  Или, при желании, вы можете установить его с помощью:  
  `pip install poetry`
  
## _Инициализация poetry в проекте_
- Перейдите в корневую директорию вашего проекта: `cd fastApiProject_Streaming`, затем инициализируйте poetry командой:
  `poetry init`


 - Следуйте инструкциям в терминале.  

  Poetry предложит вам ввести зависимости, если они у вас есть, или можно просто нажать
  Enter, чтобы пропустить этот шаг.
  
## _Перемещение зависимостей_
   Если у вас уже есть файл `requirements.txt`, вы можете импортировать все зависимости из него.  
   
   Это можно сделать с помощью команды:
   `poetry add $(cat requirements.txt)`.  

   Команда создаст файл `pyproject.toml`, где будут перечислены все ваши зависимости.
  

## _Установка зависимостей_
   После добавления зависимостей вы можете установить их командой:  
   `poetry install`.  

   Эта команда создаст виртуальную среду, которая не будет явно отображаться в файлах проекта и установит все зависимости, указанные в `pyproject.toml`.
  
## _Перенос конфигурации_
   Если у вас в проекте есть дополнительные параметры, такие как зависимости разработки или инструменты, укажите их в
   `pyproject.toml`.  

   Вы можете редактировать этот файл вручную или использовать команды `poetry add --dev` для автоматического добавления
   зависимостей.
  

## _Активация poetry_
   Poetry управляет виртуальными средами автоматически.  

   Чтобы работать в среде проекта, вам нужно активировать её командой:
   `poetry shell`
  

## _Замена команд pip_ (по желанию)
   
   Вместо `pip` вы можете использовать следующие команды poetry:
  
  - Для установки пакета:
  `poetry add package_name`
  
  - Для удаления пакета:
  `poetry remove package_name`
  
  - Для обновления всех пакетов:
  `poetry update`
  
  - Для установки пакетов разработки:
  `poetry add --dev package_name`
  
## _Удаление requirements.txt (по желанию)_
  
  Теперь проект полностью использует poetry для управления зависимостями и создания виртуальной среды.

   Все зависимости будут подтягиваться из `pyproject.toml`.

   Если вы уверены, что всё работает корректно - вы можете удалить `requirements.txt`.


## _Почему я рекомендую юзать poetry вместо pip_

- Poetry автоматически разрешает конфликты зависимостей, подбирает совместимые версии!


- Удобное добавление `poetry add ...` и обновление `poetry update` зависимостей.  


- Poetry автоматически создаёт и управляет виртуальным окружением (нет секса с `venv`, он вообще спрятан).


- Фиксация версий в `poetry.lock`, что гарантирует воспроизводимость виртуального окружения (нет секса с постоянным `pip freeze > requirements.txt`).  


- Удобный переход в виртуальное окружение `poetry shell` (а не `python -m venv`, `venv/bin/activate`).  


- Встроенная проверка на уязвимости `poetry check --security`.  


- Разделение зависимостей на группы (dev, test, docs).


Почитать, например, здесь:  
https://pythonchik.ru/okruzhenie-i-pakety/menedzher-zavisimostey-poetry-polnyy-obzor-ot-ustanovki-do-nastroyki


# РАБОТА С `.env`
______________________________________________________

Чтобы передать инфу из `.env` в другие файлы проекта нужно установить зависимость `dotenv`:

`poetry add dotenv`


# НАЗНАЧЕНИЕ ПАПОК
______________________________________________________
## _streaming_app_authorization/_  
   Папка, содержащая логику для микросервиса авторизации юзера.


## _schemas/_  
   Папка содержит файлы с Pydantic-схемами.  
   Pydantic-схемамы используются для валидации входящих данных и сериализации выходящих.


## _routes/_  
  Содержит определения маршрутов (эндпоинтов) API.


## _services/_ 
   Папка для бизнес-логики (обработка данных, взаимодействие с БД).


## _database/_
   Настройки подключения к базе данных, ORM-определения и другие базы данных.
 

## _utils/_
   Утилиты и вспомогательные функции для приложения.

      
## _tests/_
   Папка для тестовых файлов.  
   Для каждой логики - свой файл с тестами.

      test_authorization.http
      test_main.http
      test_users.http

## _docker_compose/_  
   Папка для файлов, связанных с Докером


# НАЗНАЧЕНИЕ ФАЙЛОВ
______________________________________________________

## _.gitignore_  
   Указывает, какие файлы или папки следует игнорировать при использовании Git.


## _.env_  
   Файл с конфиденциальной инфой


## _.env.example_  
   Предварительный файл с конфиденциальной инфой


## _Dockerfile_  
   Предназначен для сборки Докер-контейнеров.  

   Внутри указываются директории, файлы и зависимости проекта, которые при сборке помещаются внутрь контейнеров.


## _storages.yaml_
   Конфиг-файл для БД.

   Хранит настройки БД, кеша, файловых хранилищ (S3, Redis)

   Юзается, чтобы не храниь конфиги прямо в коде.  
   Альтернатива `.env` для БД


## _Makefile_
   Файл для автоматизации. Вместо длинных команд - короткие.


## _poetry.lock_
   Файл для фиксации точных версий всех зависимостей проекта.

   Проще -  это "снимок" зависимостей для полной предсказуемости.

   *Не редактировать вручную!*  
   Обновляется автоматически через `poetry add/update`


## _pyproject.toml_  
   Центральный конфигурационный файл.  
   
   Содержит зависимости проекта.  
   
   Обязателен, если юзаешь poetry


## _ __init__.py _

- ### Определение пакета:
Наличие файла `__init__.py` в директории делает эту директорию пакетом Python.  

Без этого файла Python не будет распознавать директорию как пакет, и мы не сможем импортировать модули из этой директории.

- ### Инициализация пакета:  
Когда импортируем пакет, Python выполняет код, содержащийся в `__init__.py`.  
Это может быть полезно для выполнения инициализации пакета или определения конфигурации.

- ### Упрощение импорта:  
Внутри файла `__init__.py` можно определить, какие классы или функции экспортировать, а какие - нет.  
Позволяет использовать сокращенные пути
импорта.


# НАЧАЛЬНАЯ СТРУКТУРА ПРОЕКТА
______________________________________________________

      fastApiProject_Streaming/
      ├── streaming_app/
      │ ├── __init__.py # Инициализационный файл пакета
      │ ├── main.py # Основной файл приложения FastAPI
      │ ├── schemas/ # Папка для Pydantic схем
      │ │ ├── __init__.py
      │ │ └── user.py # Схемы для пользователя
      │ ├── routes/ # Папка для маршрутов API
      │ │ ├── __init__.py
      │ │ └── user.py # Маршруты для работы с пользователями
      │ ├── services/ # Папка для бизнес-логики
      │ │ ├── __init__.py
      │ │ └── authorization_service.py # Логика для работы с авторизацией
      │ ├── database/ # Папка для работы с базой данных
      │ │ ├── __init__.py
      │ │ └── db.py # Настройки подключения к БД и интерпретация моделей
      │ └── utils/ # Утилитарные функции
      │ ├── __init__.py
      │ └── helpers.py # Вспомогательные функции
      ├── tests/ # Папка для тестов
      │ ├── __init__.py
      │ ├── test_main.py # Тесты для main.py
      │ └── test_users.py # Тесты для пользовательских маршрутов
      ├── .gitignore # Файл для исключения из Git
      └── README.md # Описание проекта

